;    s.HelloW
;


; headers

        GET     ^.AsmHdrs.h.SWINames

; macro


        MACRO
$label  ADDL    $reg, $var
        LCLA    count
        LCLA    varcopy
        LCLA    value
varcopy SETA    $var
count   SETA    0
        WHILE   varcopy > 0
      [ varcopy :AND: 3 = 0
varcopy SETA    varcopy :SHR: 2
count   SETA    count + 2
      |
value   SETA    (varcopy :AND: 255) :SHL: (count)
        ADD     $reg, $reg, #&$value
varcopy SETA    varcopy :SHR: 8
count   SETA    count + 8
      ]
        WEND
        MEND


        MACRO
$label  ADDR    $reg, $dest, $cond
$label  ADR$cond.L $reg, $dest
        MEND

                GBLA    addr_verbose
addr_verbose    SETA    0
        MACRO
$label  addr    $reg, $object, $cc
        LCLA    value
value   SETA    .-$object+8
        Immediate &$value
 [ immediate
$label  ADR$cc  $reg, $object
  [ addr_verbose :AND: 1 <> 0
 ! 0,"addr saved a word"
  ]
 |
$label  ADR$cc.L $reg, $object
  [ addr_verbose :AND: 2 <> 0
 ! 0,"addr didn't save a word"
  ]
 ]
        MEND


        MACRO
$label  DEC     $reg,$by
        [ "$by" = ""
$label  SUB     $reg,$reg,#1
        |
$label  SUB     $reg,$reg,#$by
        ]
        MEND



        MACRO
$label  DivRem  $rc, $ra, $rb, $rtemp, $norem
$label
     [ NoARMVE
        MOV     $rtemp, $rb
        CMP     $rtemp, $ra, LSR #1
01
        MOVLS   $rtemp, $rtemp, LSL #1
        CMPLS   $rtemp, $ra, LSR #1
        BLS     %BT01
        MOV     $rc, #0
02
        CMP     $ra, $rtemp
        SUBCS   $ra, $ra, $rtemp
        ADC     $rc, $rc, $rc
        MOV     $rtemp, $rtemp, LSR #1
        CMP     $rtemp, $rb
        BCS     %BT02
     ELIF ("$rb" :LEFT: 1) == "#"
        MOV     $rtemp, $rb
        UDIV    $rc, $ra, $rtemp
      [ "$norem" == ""
        MLS     $ra, $rtemp, $rc, $ra
      ]
     |
        UDIV    $rc, $ra, $rb
      [ "$norem" == ""
        MLS     $ra, $rb, $rc, $ra
      ]
     ]
        MEND

        MACRO
$label  Error   $errno, $errstr
$label  ADR     R0, %FT01
        SWI     OS_GenerateError
01
        &       $errno
        =       "$errstr", 0
        ALIGN
        MEND


        MACRO
$label  INC     $reg,$by
        [ "$by" = ""
$label  ADD     $reg,$reg,#1
        |
$label  ADD     $reg,$reg,#$by
        ]
        MEND



        MACRO
$label  MULTIPLY $rc, $ra, $rb
$label  MUL     $rc, $rb, $ra
        MEND




        MACRO
$label  Pull    $reglist, $cond, $hat
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   "$hat" = ""
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  LDR$cond $reglist, [r13], #4
        |
$label  LDM$cond.FD r13!, {$reglist}$hat
        ]
        MEND


        MACRO
$label  Push   $reglist, $cond
        LCLS   temps
        LCLL   onereg
temps   SETS   "$reglist"
onereg  SETL   {TRUE}
        WHILE  onereg :LAND: :LEN: temps > 0
        [ temps :LEFT: 1 = "," :LOR: temps :LEFT: 1 = "-"
onereg  SETL   {FALSE}
        ]
temps   SETS   temps :RIGHT: (:LEN: temps - 1)
        WEND
        [ onereg
$label  STR$cond $reglist, [r13, #-4]!
        |
$label  STM$cond.FD r13!, {$reglist}
        ]
        MEND


        MACRO
$label  Swap    $ra, $rb, $cc
$label  EOR$cc  $ra, $ra, $rb
        EOR$cc  $rb, $ra, $rb
        EOR$cc  $ra, $ra, $rb
        MEND




; constants

; window flags

WF_Movable              EQU     &2
WF_WimpRedraws          EQU     &10
WF_Pane                 EQU     &20
WF_Outside              EQU     &40
WF_NoBackClose          EQU     &80
WF_ScrollReqAR          EQU     &100
WF_ScrollReq            EQU     &200
WF_GCOLours             EQU     &400
WF_NoBelow              EQU     &800
WF_HotKeys              EQU     &1000
WF_StayOnScreen         EQU     &2000
WF_IgnoreR              EQU     &4000
WF_IgnoreL              EQU     &8000
WF_OpenQ                EQU     &10000
WF_OnTopQ               EQU     &20000
WF_FullSizeQ            EQU     &40000
WF_ToggleSizeQ          EQU     &80000
WF_InputFocusQ          EQU     &100000
WF_ForceOnScreenQ       EQU     &200000
WF_BackIcon             EQU     &81000000
WF_CloseIcon            EQU     &82000000
WF_TitleBar             EQU     &84000000
WF_ToggleSizeIcon       EQU     &88000000
WF_VScrollBar           EQU     &90000000
WF_AdjSizeIcon          EQU     &a0000000
WF_HScrollBar           EQU     &c0000000

WFLAG  EQU  WF_Movable :OR:  WF_ScrollReqAR  :OR:  WF_IgnoreR   :OR:  WF_IgnoreL  :OR:  WF_BackIcon  :OR:  WF_CloseIcon  :OR:  WF_VScrollBar  :OR:  WF_AdjSizeIcon  :OR: WF_HScrollBar  :OR:  WF_ToggleSizeIcon  :OR: WF_TitleBar

; windowblock offsets
;
wminx      EQU  0
wminy      EQU  4
wmaxx      EQU  8
wmaxy      EQU 12
xscrl      EQU 16
yscrl      EQU 20
bhind      EQU 24
wflags     EQU 28
tfg        EQU 32
tbg        EQU 33
wafg       EQU 34
wabg       EQU 35
sboc       EQU 36
sbic       EQU 37
tbgf       EQU 28
extra      EQU 39
waminy     EQU 40
waminx     EQU 44
wamaxx     EQU 48
wamaxy     EQU 52
tbflags    EQU 56
wbtype     EQU 60
sablock    EQU 64
minw       EQU 68
minh       EQU 70
title      EQU 72
numcons    EQU 84
icon0      EQU 88

; characters
;

TAB     *       9
CR      *       13
LF      *       10
HSP     *       31             ; hard space
Esc     *       27

        AREA    |data|, DATA,  READWRITE

        ALIGN   256

task    DCB     "TASK"
name    DCB      "A Wimp TASK", 0
        DCD  0



; filter wimp messages
;
wanted  DCB  1,2,3,4,5,6,7,8,9,10,11,12,17,18,19,0

mask    DCD  2_11100000110001

        ALIGN 256



hello   DCB  "Hello, the quick brown fox .. "
        DCB  "Jumped over the Lazy Dog .. "
        DCB  "This is the age of the train!"
        DCB  " A Snafu.", 0
        ALIGN
clickit
        DCB  "Clicked ", 0
        ALIGN
bye     DCB  "Bye",0
        ALIGN
ureq    DCB  "User Request message",0
        ALIGN
prebye  DCB  "Ready to quit?",0
        ALIGN
bytes   DCB  " Bytes available", 0
        ALIGN
m1      DCB  "PAGE# ", 0
        ALIGN
m2      DCB  " LINE# ", 0
        ALIGN
m3      DCB  " COL# ", 0
        ALIGN
m4      DCB  " Polls: ", 0
        ALIGN
m6      DCB  " Polls: ", 0
        ALIGN

minver  DCD 310                     ; required os version


; variables

osver   DCD     0                   ; our OS version
thndl   DCD     0                   ; our Wimp task Handle
ramlim  DCD     0                   ; end of our memory
send    DCD     0                   ; end of scratch

        ALIGN   256

evtcd   DCD     0                   ; event code
hwnd    DCD     0                   ; some useful poll values
pollwd  DCD     0                   ; poll word
sender  DCD     0                   ; Sender handle
fini    DCD     0                   ; finished?
action  DCD     0                   ; poll action
trips   DCD     0                   ; messages polled.

minxy
minx    DCD     0
miny    DCD     0



        ALIGN   256

; sprite control
;
sprname DCB  "offscn", 0, 0
sprtptr
        DCD     0
sprx    DCD     800
spry    DCD     600
sprdir  DCD     0

sprcoord
        DCD     0
        DCD     -32


; initial settings used to create/open our window.
;



whwnd  DCD 0
winsetting                           ; used to open window.
wincoords
        DCD  100, 100, 1636, 1120    ; minx, miny, maxx, maxy
winscroll
        DCD  0, 8                    ; scroll
winbehind
        DCD  -1                      ; behind
winflags
        DCD WFLAG                    ; &FF00C152
wincols                              ; colours
        DCB  7, 2, 1, &FF            ; we draw background.
        DCB  3, 1, 12, 0
winwa                                ; work area
        DCD  0,0,1532,1020

        DCD  &3D                     ; tiflags
        DCD  BT_ClickAR              ; wbtype
        DCD  1                       ; sprite area 1=wimp
        DCW  1532, 1020              ; min size (words)

wintitle
        DCB     "My Window",0,0,0,0,0,0
        ALIGN
winicons
        DCD  0
        SPACE 512


; button constants
;


BT_Ignore      EQU &0000
BT_Over        EQU &1000
BT_ClickAR     EQU &2000
BT_Click       EQU &3000
BT_Release     EQU &4000
BT_2Click      EQU &5000
BT_ClickDrag   EQU &6000
BT_ReleaseDrag EQU &7000
BT_2ClickDrag  EQU &8000
BT_OverClick   EQU &9000
BT_1Drag2      EQU &a000
BT_1Drag       EQU &b000
BT_CaretDrag   EQU &e000
BT_Caret       EQU &f000


; offsets

wherex  EQU     0
wherey  EQU     4
whereb  EQU     8
whereh  EQU     12
wherei  EQU     16
wheresz EQU     24




; -- Memory Map ----------------------------------


slot         EQU    8388606
topmem       EQU    8388606
sbase        EQU    4177920
sasize       EQU    3500000
sp0          EQU    sbase - 1024

where        EQU    sp0 - 16384
sprsav       EQU    where - 512
scratch      EQU    sprsav - 512

; -- --------------------------------------------
updt       EQU    scratch - 512
updt_hndl  EQU    updt + 0
updt_x     EQU    updt + 4
updt_y     EQU    updt + 8
updt_xx    EQU    updt + 12
updt_xy    EQU    updt + 16
updt_sx    EQU    updt + 20
updt_sy    EQU    updt + 24
updt_rx    EQU    updt + 28
updt_ry    EQU    updt + 32
updt_rxx   EQU    updt + 36
updt_rxy   EQU    updt + 40

; -- Poll ---------------------------------------

pollbase  EQU    updt - 512
poll      EQU    pollbase

; -- Colours

cpaper    EQU  &00FFFF
cpen      EQU  &FF3333
ccur1     EQU  &FFFF00
ccur2     EQU  &FFFF00

cbase     EQU    pollbase - 512
colours   EQU    cbase
fgcol     EQU    cbase + 0
bgcol     EQU    cbase + 4
c1col     EQU    cbase + 8
c2col     EQU    cbase + 12


; -- Text Pages
; 60 page text editor for text overlay.

textpgs   EQU    60
textsz    EQU    2728 + 88
textvars  EQU    cbase - 512
cursor    EQU    textvars
curx      EQU    textvars
cury      EQU    textvars + 4
textpg    EQU    textvars + 8

textpad   EQU    textvars + 32

pageptr   EQU    textvars + 36

pageptr0  EQU    pageptr + 4

texttop   EQU    textvars - 1024
textpg0   EQU    texttop - textsz
textpg1   EQU    textpg0 - textsz
textpg2   EQU    textpg1 - textsz
textpg3   EQU    textpg2 - textsz
textpg4   EQU    textpg3 - textsz
textpg5   EQU    textpg4 - textsz
textpg6   EQU    textpg5 - textsz
textpg7   EQU    textpg6 - textsz
textpg8   EQU    textpg7 - textsz
textpg9   EQU    textpg8 - textsz
textpg10  EQU    textpg9 - textsz
textpg11  EQU    textpg10 - textsz
textpg12  EQU    textpg11 - textsz
textpg13  EQU    textpg12 - textsz
textpg14  EQU    textpg13 - textsz
textpg15  EQU    textpg14 - textsz
textpg16  EQU    textpg15 - textsz
textpg17  EQU    textpg16 - textsz
textpg18  EQU    textpg17 - textsz
textpg19  EQU    textpg18 - textsz
textpg20  EQU    textpg19 - textsz
textpg21  EQU    textpg20 - textsz
textpg22  EQU    textpg21 - textsz
textpg23  EQU    textpg22 - textsz
textpg24  EQU    textpg23 - textsz
textpg25  EQU    textpg24 - textsz
textpg26  EQU    textpg25 - textsz
textpg27  EQU    textpg26 - textsz
textpg28  EQU    textpg27 - textsz
textpg29  EQU    textpg28 - textsz
textpg30  EQU    textpg29 - textsz
textpg31  EQU    textpg30 - textsz
textpg32  EQU    textpg31 - textsz
textpg33  EQU    textpg32 - textsz
textpg34  EQU    textpg33 - textsz
textpg35  EQU    textpg34 - textsz
textpg36  EQU    textpg35 - textsz
textpg37  EQU    textpg36 - textsz
textpg38  EQU    textpg37 - textsz
textpg39  EQU    textpg38 - textsz
textpg40  EQU    textpg39 - textsz
textpg41  EQU    textpg40 - textsz
textpg42  EQU    textpg41 - textsz
textpg43  EQU    textpg42 - textsz
textpg44  EQU    textpg43 - textsz
textpg45  EQU    textpg44 - textsz
textpg46  EQU    textpg45 - textsz
textpg47  EQU    textpg46 - textsz
textpg48  EQU    textpg47 - textsz
textpg49  EQU    textpg48 - textsz
textpg50  EQU    textpg49 - textsz
textpg51  EQU    textpg50 - textsz
textpg52  EQU    textpg51 - textsz
textpg53  EQU    textpg52 - textsz
textpg54  EQU    textpg53 - textsz
textpg55  EQU    textpg54 - textsz
textpg56  EQU    textpg55 - textsz
textpg57  EQU    textpg56 - textsz
textpg58  EQU    textpg57 - textsz
textpg59  EQU    textpg58 - textsz
textpg60  EQU    textpg59 - textsz
textbase  EQU    textpg60 - textsz



; -- Keyboard input

kbdbase   EQU    textbase - 512
khdl      EQU    kbdbase + 0
kiconhdl  EQU    kbdbase + 4
kxcaret   EQU    kbdbase + 8
kycaret   EQU    kbdbase + 12
kcgf      EQU    kbdbase + 16
kcidx     EQU    kbdbase + 20
kcode     EQU    kbdbase + 24

; insert/overwrite
insovr    EQU    kbdbase + 32



; program code

        AREA    |code|, CODE,  READONLY

        CODE32
        ALIGN 1024


; key pressed

colns  EQU  88
rowns  EQU  30
pagen  EQU  60



blankText ROUT

       Push   "r0-r5, lr"
       LDR    r4, =pageptr
       LDR    r4, [r4]
       LDR    r5, =textsz
       SUB    r4, r4, r5
       LDR    r0, =&20202020
       MOV    r1, r0
       MOV    r2, r0
       MOV    r3, r0
10     STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       DEC    r5, colns
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       DEC    r5, colns
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       DEC    r5, colns
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       DEC    r5, colns
       CMP    r5, #0
       BGT    %10
       Pull   "r0-r5, pc"


blankAllText ROUT

       Push   "r0-r5, lr"
       LDR    r4, =textbase
       LDR    r0, =&20202020
       LDR    r5, =texttop-(88*4)
       MOV    r1, r0
       MOV    r2, r0
       MOV    r3, r0
10     STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1,r2,r3}
       STMIA  r4!, {r0,r1} ; 88..
       CMP    r4, r5
       BLT    %10
       Pull   "r0-r5, pc"



;
statusBar

       Push   "r0-r8, lr"

       LDR     r1, =&AAAAAA
       MOV     r0, #0
       SWI     OS_SetColour

       MOV    r0, #5
       SWI    OS_WriteC ; at graphics point

       MOV    r1, #16
       MOV    r2, #22
       MOV    r0, #180
       SWI    OS_Plot

       LDR     r2, =cursor
       LDMIA   r2, {r4, r5, R6}
       ADDR    r0, m2
       SWI     OS_Write0

       MOV     R0, R5
       MOV     r2, #160
       ADDR    r1, scratch
       SWI     OS_ConvertInteger4
       ADDR    r0, scratch
       SWI     OS_Write0

       MOV    r1, #200
       MOV    r2, #22
       MOV    r0, #180
       SWI    OS_Plot

       ADDR    r0, m3
       SWI     OS_Write0

       MOV     R0, R4
       MOV     r2, #160
       ADDR    r1, scratch
       SWI     OS_ConvertInteger4
       ADDR    r0, scratch
       SWI     OS_Write0

       MOV    r1, #400
       MOV    r2, #22
       MOV    r0, #180
       SWI    OS_Plot

       ADDR    r0, m1
       SWI     OS_Write0

       MOV     R0, R6
       MOV     r2, #160
       ADDR    r1, scratch
       SWI     OS_ConvertInteger4
       ADDR    r0, scratch
       SWI     OS_Write0
       Pull  "r0-r8, pc"

; cursor keys move within text

leftArrow
       Push   "r0-r1, lr"
       LDR   r1, =cursor
       LDR   r0, [r1]
       CMP   r0, #1
       SUBGT r0, r0, #1
       STRGT r0, [r1]
       Pull  "r0-r1, pc"

rightArrow
       Push   "r0-r2, lr"
       LDR   r1, =cursor
       LDR   r0, [r1]
       MOV   r2, #colns
       SUB   r2, r2, #1
       CMP   r0, r2
       ADDLT r0, r0, #1
       STRLT r0, [r1]
       Pull  "r0-r2, pc"

downArrow
       Push   "r0-r1, lr"
       LDR   r1, =cursor
       LDR   r0, [r1, #4]
       CMP   r0, #rowns
       ADDLT r0, r0, #1
       STRLT r0, [r1,#4]
       Pull  "r0-r1, pc"

upArrow
       Push   "r0-r1, lr"
       LDR   r1, =cursor
       LDR   r0, [r1,#4]
       CMP   r0, #0
       SUBGT r0, r0, #1
       STRGT r0, [r1,#4]
       Pull  "r0-r1, pc"

cpyKeyPress
       Push   "r0-r9, lr"
       LDR    r9, =poll
       LDR    r8, =kbdbase
       LDMIA  r9, {r0,r1,r2,r3,r4,r5,r6,r7}
       STMIA  r8, {r0,r1,r2,r3,r4,r5,r6,r7}
       Pull   "r0-r9, pc"

initPagePtrs
       Push  "r0,r4, lr"
       LDR   r4, =pageptr0
       LDR   r0, =textpg0
       STR   r0, [r4]
       LDR   r0, =textpg1
       STR   r0, [r4, #4]
       LDR   r0, =textpg2
       STR   r0, [r4, #8]
       LDR   r0, =textpg3
       STR   r0, [r4,#12]
       LDR   r0, =textpg4
       STR   r0, [r4,#16]
       LDR   r0, =textpg5
       STR   r0, [r4,#20]
       LDR   r0, =textpg6
       STR   r0, [r4,#24]
       LDR   r0, =textpg7
       STR   r0, [r4,#28]
       LDR   r0, =textpg8
       STR   r0, [r4,#32]
       LDR   r0, =textpg9
       STR   r0, [r4,#36]
       LDR   r0, =textpg10
       STR   r0, [r4,#40]
       LDR   r0, =textpg11
       STR   r0, [r4,#44]
       LDR   r0, =textpg12
       STR   r0, [r4,#48]
       LDR   r0, =textpg13
       STR   r0, [r4,#52]
       LDR   r0, =textpg14
       STR   r0, [r4,#56]
       LDR   r0, =textpg15
       STR   r0, [r4,#60]
       LDR   r0, =textpg16
       STR   r0, [r4,#64]
       LDR   r0, =textpg17
       STR   r0, [r4,#68]
       LDR   r0, =textpg18
       STR   r0, [r4,#18*4]
       LDR   r0, =textpg19
       STR   r0, [r4,#19*4]
       LDR   r0, =textpg20
       STR   r0, [r4,#20*4]
       LDR   r0, =textpg21
       STR   r0, [r4,#21*4]
       LDR   r0, =textpg22
       STR   r0, [r4,#22*4]
       LDR   r0, =textpg23
       STR   r0, [r4,#23*4]
       LDR   r0, =textpg24
       STR   r0, [r4,#24*4]
       LDR   r0, =textpg25
       STR   r0, [r4,#25*4]
       LDR   r0, =textpg26
       STR   r0, [r4,#26*4]
       LDR   r0, =textpg27
       STR   r0, [r4,#27*4]
       LDR   r0, =textpg28
       STR   r0, [r4,#28*4]
       LDR   r0, =textpg29
       STR   r0, [r4,#29*4]
       LDR   r0, =textpg30
       STR   r0, [r4,#30*4]
       LDR   r0, =textpg31
       STR   r0, [r4,#31*4]
       LDR   r0, =textpg32
       STR   r0, [r4,#32*4]
       LDR   r0, =textpg33
       STR   r0, [r4,#33*4]
       LDR   r0, =textpg34
       STR   r0, [r4,#34*4]
       LDR   r0, =textpg35
       STR   r0, [r4,#35*4]
       LDR   r0, =textpg36
       STR   r0, [r4,#36*4]
       LDR   r0, =textpg37
       STR   r0, [r4,#37*4]
       LDR   r0, =textpg38
       STR   r0, [r4,#38*4]
       LDR   r0, =textpg39
       STR   r0, [r4,#39*4]
       LDR   r0, =textpg40
       STR   r0, [r4,#40*4]
       LDR   r0, =textpg41
       STR   r0, [r4,#41*4]
       LDR   r0, =textpg42
       STR   r0, [r4,#42*4]
       LDR   r0, =textpg43
       STR   r0, [r4,#43*4]
       LDR   r0, =textpg44
       STR   r0, [r4,#44*4]
       LDR   r0, =textpg45
       STR   r0, [r4,#45*4]
       LDR   r0, =textpg46
       STR   r0, [r4,#46*4]
       LDR   r0, =textpg47
       STR   r0, [r4,#47*4]
       LDR   r0, =textpg48
       STR   r0, [r4,#48*4]
       LDR   r0, =textpg49
       STR   r0, [r4,#49*4]
       LDR   r0, =textpg50
       STR   r0, [r4,#50*4]
       LDR   r0, =textpg51
       STR   r0, [r4,#51*4]
       LDR   r0, =textpg52
       STR   r0, [r4,#52*4]
       LDR   r0, =textpg53
       STR   r0, [r4,#53*4]
       LDR   r0, =textpg54
       STR   r0, [r4,#54*4]
       LDR   r0, =textpg55
       STR   r0, [r4,#55*4]
       LDR   r0, =textpg56
       STR   r0, [r4,#56*4]
       LDR   r0, =textpg57
       STR   r0, [r4,#57*4]
       LDR   r0, =textpg58
       STR   r0, [r4,#58*4]
       LDR   r0, =textpg59
       STR   r0, [r4,#59*4]
       LDR   r0, =textpg60
       STR   r0, [r4,#60*4]
       MOV   r0, #1
       LDR   r4, =textpg
       STR   r0, [r4]
       Pull  "r0,r4,pc"


setPagePtr
       Push  "r0-r5, lr"
       LDR   r4, =textpg
       LDR   r2, [r4]
       MOV   r3, #4
       MUL   r5, r2, r3
       LDR   r4, =pageptr0
       LDR   r0, [r4,r5]
       LDR   r5, =pageptr
       STR   r0, [r5]
       Pull  "r0-r5,pc"


       LTORG


pgupPress
pageUp ROUT

       Push  "r0-r5, lr"
       LDR   r4, =textpg
       LDR   r2, [r4]
       CMP   r2, #59
       Pull  "r0-r5,pc", GT

       ADD   r2, r2, #1
       STR   r2, [r4]
       MOV   r3, #4
       MUL   r5, r2, r3
       LDR   r4, =pageptr0
       LDR   r0, [r4,r5]
       LDR   r5, =pageptr
       STR   r0, [r5]
       BL    homeCursor
       Pull  "r0-r5,pc"


pgdnPress
pageDn
       Push  "r0-r5, lr"
       LDR   r4, =textpg
       LDR   r2, [r4]
       CMP   r2, #1
       Pull  "r0-r5,pc", LT

       SUB   r2, r2, #1
       STR   r2, [r4]
       MOV   r3, #4
       MUL   r5, r2, r3
       LDR   r4, =pageptr0
       ;ADD   r4, r4, r5
       LDR   r0, [r4,r5]
       LDR   r5, =pageptr
       STR   r0, [r5]
       BL    homeCursor
       Pull  "r0-r5,pc"



; assign default colours to fg, bg c1, c2.
initTextCols

       Push   "r0-r4, lr"
       LDR   r4, =colours
       LDR   r0, =cpaper
       LDR   r1, =cpen
       LDR   r2, =ccur1
       LDR   r3, =ccur2
       STMIA r4, {r0,r1,r2,r3}

       ; set insert mode
       MOV   r0, #1
       LDR   r2, =insovr
       STR   r0, [r2]

       ; SET PG TO 1
       MOV   r0, #1
       LDR   r2, =textpg
       STR   r0, [r2]

       ; set pageptr
       BL    setPagePtr

       Pull  "r0-r4, pc"

; set fg and bg graphics colours
setFgBgCols
       Push   "r0-r4, lr"
       LDR     r4, =colours
       LDR     r1, [r4, #0]
       MOV     r0, #0
       SWI     OS_SetColour

       LDR     r1, [r4, #4]
       MOV     r0, #16
       SWI     OS_SetColour
       Pull  "r0-r4, pc"


setStdCurCol
       Push   "r0-r2, lr"
       LDR     r2, =colours
       LDR     r1, [r2, #8]
       MOV     r0, #0
       Pull  "r0-r2, pc"


setCpyCurCol
       Push   "r0-r2, lr"
       LDR     r2, =colours
       LDR     r1, [r2, #12]
       MOV     r0, #0
       Pull  "r0-r2, pc"


homeCursor
       Push   "r0-r1, lr"
       LDR   r1, =cursor
       MOV   r0, #1
       STR   r0, [r1]
       SUB   r0, r0, #1
       STR   r0, [r1, #4]
       Pull  "r0-r1, pc"

homeLine
       Push   "r0-r1, lr"
       LDR   r1, =cursor
       MOV   r0, #1
       STR   r0, [r1]
       Pull  "r0-r1, pc"


displayCursor

       Push   "r0-r6, lr"
       BL    setCpyCurCol
       LDR   r2, =cursor
       LDMIA r2, {r0, r1}

       MOV   r3, #1000
       MOV   r5, #32
       MUL   r4, r1, r5
       SUB   r1, r3, r4

       MOV   r3, #0
       MOV   r5, #16
       MUL   r3, r0, r5
       MOV   r0, r3

       ADD   r3, r0, #8
       SUB   r4, r1, #16
       ADD   r5, r3, #16
       ADD   r6, r4, #16
       BL    doRect
       BL    setFgBgCols
       Pull  "r0-r6, pc"



enterKey ROUT

       Push  "r0-r7, lr"
       LDR   r6, =cursor
       LDMIA r6, {r4, r5}
       MOV   r1, #rowns
       CMP   r5, r1
       Pull  "r0-r7, pc", GE

       MOV   r2, r5
       CMP   r2, r1
       Pull  "r0-r7, pc", GE

010    MOV   r0, r1
       BL    lineCpyDown
       SUB   r1, r1, #1
       CMP   r2, r1
       BNE   %10

       LDR   r1, =cursor    ; down and right
       LDR   r0, [r1, #4]
       MOV   r5, r0
       CMP   r0, #rowns
       ADDLT r0, r0, #1
       STRLT r0, [r1,#4]
       MOVLT r0, #1
       STRLT r0, [r1]
       ADD   r5, r5, #2
       ; blank current line.
       MOV    r6, #colns
       LDR    r7, =pageptr
       LDR    r7, [r7]
       MUL    r1, r6, r5   ; y * colns
       SUB    r7, r7, r1   ; from top
       ; space fill
       LDR    r0, =&20202020
       MOV    r1, #22
020    STR    r0, [r7]
       ADD    r7, r7, #4
       SUB    r1, r1, #1
       CMP    r1, #0
       BNE    %020

       Pull  "r0-r7, pc"



; blank line below ctrl n; perhaps ctrl enter

CtrlN ROUT

       Push  "r0-r7, lr"
       LDR   r6, =cursor
       LDMIA r6, {r4, r5}
       MOV   r1, #rowns
       CMP   r5, r1
       Pull  "r0-r7, pc", GE

       MOV   r2, r5
       CMP   r2, r1
       Pull  "r0-r7, pc", GE

010    MOV   r0, r1
       BL    lineCpyDown
       SUB   r1, r1, #1
       CMP   r2, r1
       BNE   %10

       LDR   r1, =cursor    ; down and right
       LDR   r0, [r1, #4]
       MOV   r5, r0
       CMP   r0, #rowns
       ADDLT r0, r0, #1
       STRLT r0, [r1,#4]
       MOVLT r0, #1
       STRLT r0, [r1]
       ADD   r5, r5, #2
       ; blank current line.
       MOV    r6, #colns
       LDR    r7, =pageptr
       LDR    r7, [r7]
       MUL    r1, r6, r5   ; y * colns
       SUB    r7, r7, r1   ; from top

       ; space fill
       LDR    r0, =&20202020
       MOV    r1, #22
020    STR    r0, [r7]
       ADD    r7, r7, #4
       SUB    r1, r1, #1
       CMP    r1, #0
       BNE    %020

       Pull  "r0-r7, pc"

; duplicate this line below.

CtrlD  ROUT

       Push  "r0-r5, lr"
       LDR   r6, =cursor
       LDMIA r6, {r4, r5}
       MOV   r1, #rowns
       CMP   r5, r1
       Pull  "r0-r5, pc", GE

       MOV   r2, r5
       CMP   r2, r1
       Pull  "r0-r5, pc", GE

010    MOV   r0, r1
       BL    lineCpyDown
       SUB   r1, r1, #1
       CMP   r2, r1
       BNE   %10
       Pull  "r0-r5, pc"


; kill this line and move up

CtrlK  ROUT

       Push  "r0-r5, lr"
       LDR   r6, =cursor
       LDMIA r6, {r4, r5}
       MOV   r1, #rowns
       CMP   r5, r1
       Pull  "r0-r5, pc", GE

010    ADD   r0, r5, #1
       BL    lineCpyUp
       ADD   r5, r5, #1
       CMP   r5, r1
       BLE   %10
       Pull  "r0-r5, pc"

; r0 = row, copy up to next line.
lineCpyUp

       Push  "r0-r8, lr"
       MOV    r6, #colns
       LDR    r7, =pageptr
       LDR    r7, [r7]
       MUL    r1, r6, r0   ; y * colns
       SUB    r7, r7, r1   ; from top

       LDR    r8, =pageptr
       LDR    r8, [r8]
       ADD    r0, r0, #1  ; y + 1
       MUL    r1, r6, r0
       SUB    r8, r8, r1
       MOV    r5, r7
       MOV    r7, r8
       MOV    r8, r5
       B      copyLine


; r0 = row, copy down to next line.
lineCpyDown
       Push  "r0-r8, lr"
       MOV    r6, #colns
       LDR    r7, =pageptr
       LDR    r7, [r7]
       MUL    r1, r6, r0   ; y * colns
       SUB    r7, r7, r1   ; from top

       LDR    r8, =pageptr
       LDR    r8, [r8]
       ADD    r0, r0, #1  ; y +1
       MUL    r1, r6, r0
       SUB    r8, r8, r1

copyLine ROUT

       ; copy from r7 to r8; 88 bytes.
       MOV r3, #11
010    LDMIA  r7, {r0, r1}
       STMIA  r8, {r0, r1}
       ADD    r7, r7, #8
       ADD    r8, r8, #8
       SUB    r3, r3, #1
       CMP    r3, #0
       BNE    %10

       Pull  "r0-r8, pc"



displayAblePress ROUT  ; in r0

       Push   "r1-r8, lr"
       LDR    r7, =pageptr
       LDR    r7, [r7]
       LDR    r8, =cursor
       MOV    r6, #colns

       LDMIA  r8, {r3, r4}
       CMP    r3, r6
       Pull   "r1-r8, pc", EQ

       ADD    r4, r4, #1
       MUL    r1, r4, r6   ; y * colns
       SUB    r1, r1, r3   ; + x
       SUB    r7, r7, r1   ; from top
       LDR    r5, =insovr
       LDR    r2, [r5]
       CMP    r2, #0
       BEQ    %01

       ; move text in line and insert

       SUB    r5, r6, r3 ; colns - x
       CMP    r5, #0
       BLEQ   %01

       ADD    r8, r7, r5 ; end of row
       SUB    r8, r8, #2
02     SUB    r5, r5, #1 ; -1
       LDRB   r1, [r8]
       STRB   r1, [r8, #1]
       SUB    r8, r8, #1
       CMP    r5, #0
       BNE    %02

01     STRB   r0, [r7]
       BL     rightArrow   ; advance
       Pull   "r1-r8, pc"


; bug at end of line in ins mode



delKeyPress   ROUT

       Push   "r0-r8, lr"
       MOV    r0, #&20
       LDR    r7, =pageptr
       LDR    r7, [r7]
       LDR    r8, =cursor
       MOV    r6, #colns
       LDMIA  r8, {r3, r4}
       MOV    r8, r7       ;
       ADD    r4, r4, #1
       MUL    r1, r4, r6   ; y * colns
       SUB    r8, r8, r1   ; base of line
       SUB    r1, r1, r3   ; + x
       SUB    r7, r7, r1   ; from top

       ; check if the whole line is blank

       LDR    r1, =&20202020
       MOV    r5, r6, asr #4
08     LDR    r0, [r8]
       ADD    r8, r8, #4
       SUB    r5, r5, #1
       CMP    r0, r1
       BNE    %010
       CMP    r5, #0
       BNE    %08

       ; delete blank line
       BL     CtrlK
       LDR    r1, =cursor
       MOV    r0, #1
       STR    r0, [r1]
       Pull   "r0-r8, pc", GE


010    SUB    r5, r6, r3   ; colns - x
       CMP    r5, #0
       BLEQ   %01

       CMP    r5, #1
       BNE    %05
       B      %04

       CMP    r3, #1
       B      %04

       Pull   "r0-r8, pc"
05     ADD    r6, r6, #1
       MOV    r8, r7
       SUB    r8, r8, #1
02     SUB    r5, r5, #1   ; -1
       LDRB   r1, [r8, #1]
       STRB   r1, [r8]
       ADD    r8, r8, #1
       CMP    r5, #0
       BNE    %02
       BL     leftArrow
       Pull   "r0-r8, pc"

04     MOV    r0, #&20
01     STRB   r0, [r7]

       BL     leftArrow    ; backspace
03     Pull   "r0-r8, pc"


       LTORG

displayLines ROUT

       Push   "r0-r8, lr"
       LDR    r7, =pageptr
       LDR    r6, =textsz
       LDR    r7, [r7]
       MOV    r6, #rowns +1
       MOV    r5, #1000 ; line 0 Top of sprite
10     MOV    r1, #10
       MOV    r2, r5
       MOV    r0, #180
       SWI    OS_Plot   ; move to start of line
       MOV    r0, #5
       SWI    OS_WriteC ; at graphics point

       SUB    r0, r7, #colns
       MOV    r1, #colns
       SWI    OS_WriteN

       SUB    r6, r6, #1
       SUB    r5, r5, #32
       SUB    r7, r7, #colns ; next line
       CMP    r6, #0
       BNE    %10
       Pull   "r0-r8, pc"

refreshWindow
       Push   "r0-r4, lr"
       ADDR   r0, hwnd
       LDR    r0, [r0]
       MOV    r1, #0
       MOV    r2, #0
       MOV    r3, #1536
       MOV    r4, #1024
       SWI    Wimp_ForceRedraw
       Pull   "r0-r4, pc"


doLine ; r3, r4 to r5, r6

       Push   "r0-r2, lr"
       MOV    r1, r3
       MOV    r2, r4
       MOV    r0, #4
       SWI    OS_Plot
       MOV    r1, r5
       MOV    r2, r6
       MOV    r0, #5
       SWI    OS_Plot
       Pull   "r0-r2, pc"


doRect ; r3, r4 to r5, r6
       Push   "r0-r2, lr"
       MOV    r1, r3
       MOV    r2, r4
       MOV    r0, #4
       SWI    OS_Plot
       MOV    r1, r5
       MOV    r2, r6
       MOV    r0, #&65
       SWI    OS_Plot
       Pull   "r0-r2, pc"

toSprite

       Push   "r0-r4, lr"
       ADDR   r4, sprdir
       LDR    r0, [r4]
       CMP    r0, #1
       Pull   "r0-r4, pc", EQ

       MOV    r0, #1
       STR    r0, [r4]
       LDR    r1, =sbase

       LDR    r0, =316
       ADDR   r2, sprname
       MOV    r3, #0

       SWI    OS_SpriteOp
       LDR    r4, =sprsav
       STR    r0, [r4, #4]!
       STR    r1, [r4, #4]!
       STR    r2, [r4, #4]!
       STR    r3, [r4, #4]!
       Pull   "r0-r4, pc"

toScreen
       Push   "r0-r4, lr"
       ADDR   r4, sprdir
       LDR    r0, [r4]
       CMP    r0, #0
       Pull   "r0-r4, pc", EQ

       MOV    r0, #0
       STR    r0, [r4]

       LDR    r1, =sbase
       LDR    r4, =sprsav

       LDR    r0, [r4, #4]!
       LDR    r1, [r4, #4]!
       LDR    r2, [r4, #4]!
       LDR    r3, [r4, #4]!
       SWI    OS_SpriteOp
       Pull   "r0-r4,pc"

makeFromScreen

       Push   "r0-r8,lr"
       LDR    r0, =256+16
       LDR    r1, =sbase
       ADDR   r2, sprname
       MOV    r3, #0
       MOV    r4, #0
       MOV    r5, #0
       LDR    r6, =1540
       LDR    r7, =1050
       SWI    OS_SpriteOp
       ADDR   r8, sprtptr
       STR    r2, [r8]
       Pull   "r0-r8, pc"

initSprites

       Push   "r0-r5, lr"
       LDR    r4, =sbase
       LDR    r0, =sasize
       STR    r0, [r4]
       MOV    r0, #0
       STR    r0, [r4, #4]!
       MOV    r0, #16
       STR    r0, [r4, #4]!
       STR    r0, [r4, #4]!
       LDR    r1, =sbase
       LDR    r0, =256+9
       SWI    OS_SpriteOp
       BL     makeFromScreen
       Pull   "r0-r5, pc"

plotSpriteInPoll

       Push   "r0-r5, lr"

       LDR    r1, =poll
       LDR    r3, [r1,#4]
       LDR    r4, [r1,#8]
       ADD    r4, r4,#1

       LDR    r0, =512+34
       MOV    r1, #0
       LDR    r1, =sbase
       ADDR   r2, sprtptr
       LDR    r2, [r2]

       MOV    r5, #0
       SWI    OS_SpriteOp
       Pull   "r0-r5, pc"


; -------------------------------------------------
; ENTRY
; -------------------------------------------------

        ENTRY

        LDR     r0, =slot
        MOV     r1, #-1
        SWI     Wimp_SlotSize

        LDR     r0, =sp0
        MOV     r13, r0

        BL      initPagePtrs
        BL      initTextCols
        BL      homeCursor
        BL      blankAllText
        BL      initSprites

        BL      toSprite
        BL      setFgBgCols

        MOV     r0, #16       ; clg on sprite
        SWI     OS_WriteC
        BL      displayCursor
        BL      toScreen

        MOV     r0, #1
        ADDR    r8, task
        LDR     r1, [r8]        ; "TASK"
        ADDR    r8, minver
        LDR     r0, [r8]
        ADDR    r2, name
        ADDR    r3, wanted
        SWI     Wimp_Initialise
        ADDR    r8,  osver
        STR     r0, [r8, #4]!   ; osver
        STR     r1, [r8]        ; taskhandle to handle

        ; make and open window

        ADDR    r1, winsetting

        LDR     r0, [r1, #4]
        ADDR    r2, minx
        STR     r0, [r2]

        ADDR    r2, miny
        LDR     r0, [r2, #8]
        STR     r0, [r2]

        SWI     Wimp_CreateWindow
        ADDR    r2, hwnd
        STR     r0, [r2]

        ADDR    r1, whwnd
        STR     r0, [r1]

        SWI     Wimp_OpenWindow

        ; WIMP POLL

        EOR     r0, r0, r0
        ADDR    r8,fini
        STR     r0,[r8]


polling         ROUT

pollwimp

        MOV     r0, #1
        LDR     r1, =poll
        ADDR    r3, wanted
        ADDR    r2, thndl            ; our task handle
        LDR     r2, [r2]
        SWI     Wimp_Poll

        ADDR    r2, evtcd
        STR     r0, [r2]             ; message type
        ADDR    r3, action
        LDR     r1, [r2,#16]         ; message action
        STR     r1, [r3]
        MOV     r7, r1               ; action in r7

        CMP     r0, #0
        BEQ     qquit

        LDR     r1, =poll

amesg
       ; MOV    r6, r0
       ; BL     saymsg
       ; MOV    r0, r6

01
        CMP     r0, #1               ; draw win
        BNE     %02
        B       OnRedraw

02
        CMP     r0, #2               ; open win message (e.g. it moved)
        BNE     %03

        LDR     r0, [r1, #4]
        ADDR    r2, minx
        STR     r0, [r2]
        ADDR    r2, miny
        LDR     r0, [r2, #8]
        STR     r0, [r2]

        SWI     Wimp_OpenWindow

        B       qquit

03      CMP     r0, #3               ; close win and quit
        BNE     %04

        SWI     Wimp_DeleteWindow
        ADDR    r2, thndl
        LDR     r0, [r2]
        SWI     Wimp_CloseDown
        SWI     OS_Exit


04      CMP     r0, #4               ; pointer leaving
        BNE     %05
        BL      ptrleave
        B       qquit

05      CMP     r0, #5               ; pointer entering
        BNE     %06
        BL      ptrenter
        B       qquit

06      CMP     r0, #6               ; handle mouse click
        BNE     %07

        LDR     r2, =where           ; track where clicked.
        LDR     r0, [r1,#wherex]     ; x
        STR     r0, [r2,#wherex]
        LDR     r0, [r1,#wherey]     ; y
        STR     r0, [r2,#wherey]
        LDR     r0, [r1,#whereb]     ; button
        STR     r0, [r2,#whereb]
        LDR     r3, [r1,#whereh]     ; handle
        STR     r3, [r2,#whereh]
        LDR     r0, [r1,#wherei]     ; icon
        STR     r0, [r8,#wherei]

        MOV     r0, r3
        MOV     r1, #-1
        MOV     r2, #0
        MOV     r3, #-1
        MOV     r4, #0
        MOV     r5, #-1
        SWI     Wimp_SetCaretPosition

        ; draw at click

        BL      toSprite

        BL      setFgBgCols

        MOV     r0, #16       ; clg on sprite
        SWI     OS_WriteC

        BL      displayLines
        BL      displayCursor

        LDR     r0, =where
        LDR     r1, [r0, #wherex]
        LDR     r2, [r0, #wherey]

        ADDR    r0, minxy
        LDR     r3, [r0]
        SUB     r1, r1, r3    ; adjust x
        LDR     r3, [r0, #4]  ; min y


        MOV     r0, #180
        SWI     OS_Plot

        MOV     r0, #5
        SWI     OS_WriteC

        ADDR    r0, clickit
        SWI     OS_Write0

        LDR     r3, =where           ; display where clicked.
        LDR     r0, [r3,#wherex]     ; TODO: convert click x,y to win and sprite
        MOV     r2, #160
        LDR     r1, =scratch
        SWI     OS_ConvertInteger4
        LDR     r0, =scratch
        SWI     OS_Write0
        MOV     r0,#":"
        SWI     OS_WriteC
        LDR     r0, [r3,#wherey]     ; y
        MOV     r2, #160
        LDR     r1, =scratch
        SWI     OS_ConvertInteger4
        LDR     r0, =scratch
        SWI     OS_Write0

        MOV     r2, #2000

        MOV     r3, #0
        MOV     r4, #0
        LDR     r5, =1536
        MOV     r6, #1024
061     ADD     r4, r4, #10
        ADD     r6, r5, #10
        BL      doLine
        DEC     r2
        CMP     r2, #0
        BNE     %061


        BL      toScreen
        BL      refreshWindow

        B       qquit


07      CMP     r0, #7
        BNE     %08

        B       qquit


rarrow  EQU     &18D
larrow  EQU     &18C
clarrow EQU     &1AC
crarrow EQU     &1AD
uarrow  EQU     &18F
darrow  EQU     &18E
kinsert EQU     &1CD
kpgup   EQU     &19F
kpgdn   EQU     &19E


08      CMP     r0, #8
        BNE     %018
        BL      cpyKeyPress

        LDR     r0, [r1, #24]
        CMP     r0, #&1B
        BEQ     quit

        CMP     r0, #&20
        BLT     %081
        CMP     r0, #&7E
        BGT     %081

        BL      displayAblePress
        B       %082


081     ; special keys

        LDR     r2, =kpgup
        CMP     r0, r2   ; page up
        BLEQ    pgupPress


        LDR     r2, =kpgdn
        CMP     r0, r2   ; page down
        BLEQ    pgdnPress


        LDR     r2, =kinsert
        CMP     r0, r2   ; left
        BLEQ    CtrlD

        LDR     r2, =larrow
        CMP     r0, r2   ; left
        BLEQ    leftArrow

        LDR     r2, =clarrow
        CMP     r0, r2   ; left ctrl
        BLEQ    homeLine

        LDR     r2, =rarrow
        CMP     r0, r2   ; right
        BLEQ    rightArrow

        LDR     r2, =darrow
        CMP     r0, r2
        BLEQ    downArrow

        LDR     r2, =uarrow
        CMP     r0, r2
        BLEQ    upArrow

        CMP     r0, #13
        BLEQ    enterKey

        CMP     r0, #127    ; DELETE
        BNE     %083
        BL      rightArrow
        BL      delKeyPress

083     CMP     r0, #08     ; BACK SPACE
        BLEQ    delKeyPress

        CMP     r0, #12
        BLEQ    homeCursor
        BLEQ    blankText

        CMP     r0, #04
        BLEQ    CtrlD

        CMP     r0, #11
        BLEQ    CtrlK

        CMP     r0, #14
        BLEQ    CtrlN




082
        ; display updated text layer

        BL      toSprite
        BL      setFgBgCols

        MOV     r0, #16       ; clg on sprite
        SWI     OS_WriteC

        BL      displayLines
        BL      displayCursor
        BL      statusBar
        BL      toScreen

        BL      refreshWindow


        B       qquit




018     CMP     r0, #18       ; user message
        BNE     %17
        ; ..
        B       polling

017     CMP     r0, #17
        BNE     qquit
        CMP     r7, #0        ; quit message
        BEQ     quit


        CMP     r7, #8
        BLEQ    preq
        BEQ     qquit


qquit
        ADDR    r2, fini      ; ready to quit?
        LDR     r2, [r2]
        CMP     r2, #1
        BNE     polling



quit

        ADDR    r8, thndl
        LDR     r0, [r8]
        SWI     Wimp_CloseDown
        SWI     OS_Exit


Redrawing       ROUT
OnRedraw


        Push    "r0-r2"

        LDR     r1, =poll
        SWI     XWimp_RedrawWindow
        BVS     redraw_error

        CMP     r0, #0
        Pull    "r0-r2", EQ
        BEQ     qquit
        MOV     r2, #0
        BL      plotSpriteInPoll

nextrect

        LDR     r1, =poll
        SWI     XWimp_GetRectangle
        BVS     redraw_error

        CMP     r0, #0
        Pull    "r0-r2", EQ
        BEQ     qquit
        MOV     r0, #&13
        SWI     OS_Byte
        BL      plotSpriteInPoll

        INC     r2
        B       nextrect

redraw_error

        MOV     r0, #7
        SWI     OS_WriteC
        B       qquit

; say message


;
;saymsg
;        ADDR    r0, m1
;        SWI     OS_Write0
;
;        ADDR    r8, evtcd
;        LDR     R0, [r8]
;        MOV     r2, #160
;        ADDR    r1, scratch
;        SWI     OS_ConvertInteger4
;        ADDR    r0, scratch
;        SWI     OS_Write0
;
;        ADDR    r0, m2
;        SWI     OS_Write0
;
;        ADDR    r8, action
;        LDR     R0, [r8]
;        MOV     r2, #160
;        ADDR    r1, scratch
;        SWI     OS_ConvertHex8
;        ADDR    r0, scratch
;        SWI     OS_Write0
;
;        ADDR    r0, m3
;        SWI     OS_Write0
;
;        ADDR    r8, fini
;        LDR     R0, [r8]
;        MOV     r2, #160
;        ADDR    r1, scratch
;        SWI     OS_ConvertInteger4
;        ADDR    r0, scratch
;        SWI     OS_Write0
;
;        ADDR    r0, m4
;        SWI     OS_Write0
;
;        ADDR    r8, trips
;        LDR     R0, [r8]
;        MOV     r2, #160
;        ADDR    r1, scratch
;        SWI     OS_ConvertInteger4
;        ADDR    r0, scratch
;        SWI     OS_Write0
;
;
;        SWI     OS_NewLine
;        MOV     r15, r14


ptrenter
ptrleave
preq
        MOV     r15, r14

        ALIGN   1024

        END




